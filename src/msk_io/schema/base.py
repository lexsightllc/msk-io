# SPDX-License-Identifier: MPL-2.0
from datetime import datetime
from typing import Any, Literal
from uuid import UUID, uuid4

from pydantic import Field

from msk_io.schema._pydantic_base import MSKIOBaseModel


class Metadata(MSKIOBaseModel):
    """Common metadata fields for any data artifact or process result."""

    timestamp: datetime = Field(default_factory=datetime.now)
    source_system: str | None = None
    processed_by: str = "MSK-IO Pipeline"
    pipeline_version: str = (
        "0.0.1"  # Should be dynamically loaded from msk_io.__version__
    )


class TaskStatus(MSKIOBaseModel):
    """Represents the status of a specific pipeline task."""

    task_id: UUID = Field(default_factory=uuid4)
    task_name: str
    status: Literal["PENDING", "IN_PROGRESS", "COMPLETED", "FAILED", "SKIPPED"]
    message: str | None = None
    start_time: datetime | None = None
    end_time: datetime | None = None
    duration_seconds: float | None = None
    error_details: dict[str, Any] | None = None

    def update_status(
        self,
        new_status: Literal["PENDING", "IN_PROGRESS", "COMPLETED", "FAILED", "SKIPPED"],
        message: str | None = None,
        error_details: dict[str, Any] | None = None,
    ) -> None:
        """Updates the status of the task."""

        self.status = new_status
        self.message = message
        if new_status == "IN_PROGRESS" and self.start_time is None:
            self.start_time = datetime.now()
        elif new_status in ["COMPLETED", "FAILED", "SKIPPED"] and self.end_time is None:
            self.end_time = datetime.now()
            if self.start_time:
                self.duration_seconds = (
                    self.end_time - self.start_time
                ).total_seconds()
        self.error_details = error_details


class ProcessingResult(MSKIOBaseModel):
    """Base model for any result generated by a processing step."""

    result_id: UUID = Field(default_factory=uuid4)
    metadata: Metadata = Field(default_factory=Metadata)
    status: Literal["SUCCESS", "FAILURE", "PARTIAL_SUCCESS"] = "SUCCESS"
    message: str | None = None
    errors: list[dict[str, Any]] = Field(default_factory=list)


class FileInfo(MSKIOBaseModel):
    """Information about a file, used for input and output tracking."""

    file_path: str
    file_name: str
    file_extension: str
    file_size_bytes: int | None = None
    last_modified: datetime | None = None
    checksum: str | None = None  # e.g., MD5 or SHA256


class PipelineStatus(MSKIOBaseModel):
    """Overall status of a full pipeline run."""

    pipeline_id: UUID = Field(default_factory=uuid4)
    input_file: FileInfo | None = None
    overall_status: Literal[
        "PENDING",
        "RUNNING",
        "COMPLETED_SUCCESS",
        "COMPLETED_WITH_ERRORS",
        "FAILED",
    ]
    start_time: datetime = Field(default_factory=datetime.now)
    end_time: datetime | None = None
    total_duration_seconds: float | None = None
    tasks_status: list[TaskStatus] = Field(default_factory=list)
    final_report_path: str | None = None
    overall_message: str | None = None
    fatal_error: dict[str, Any] | None = None

    def add_task_status(self, task: TaskStatus) -> None:
        """Adds or updates a task status within the pipeline."""
        for i, existing_task in enumerate(self.tasks_status):
            if existing_task.task_id == task.task_id:
                self.tasks_status[i] = task
                return
        self.tasks_status.append(task)

    def finalize_pipeline(
        self,
        status: Literal["COMPLETED_SUCCESS", "COMPLETED_WITH_ERRORS", "FAILED"],
        message: str | None = None,
        fatal_error: dict[str, Any] | None = None,
    ) -> None:
        """Finalizes the pipeline status."""
        self.overall_status = status
        self.end_time = datetime.now()
        self.overall_message = message
        self.fatal_error = fatal_error
        self.total_duration_seconds = (self.end_time - self.start_time).total_seconds()
